; This assembly code models a calculator by
; using a stack mechanism to recognize two
; integers and one operator (postfix expressions)
; from an input to carry out a simple calculation 
; using subroutines for each operation per
; postfix expression.
;
; R0: IO for TRAPs and subroutines
; R1: Holds the operand
; R2: Holds ASCII values for comparisons
; R3: IO for subroutines
; R4: IO for subroutines
; R5: The value of the result
; R7: Used to store values of the PC 
;
.ORIG x3000
	
;your code goes here
	
START
	GETC
	OUT		; Get character from user and show them
	LD R2, ASSP
	ADD R2, R0, R2
	BRz START	; If it's a space, ignore it
	LD R2, ASZERO
	ADD R2, R0, R2
	BRn OPERAND	; If it's less than '0', it's an operand
	LD R3, ASCOL
	ADD R3, R0, R3
	BRn DIGIT	; If it's between '0' and ':', it's a digit
	LD R3, ASEQ
	ADD R3, R0, R3
	BRz FIN		; If it's '=' print the result and quit

OPERAND			; If all else fails, treat it as an operand
	ADD R1, R0, x00	; Put the input into R1
; Pop the last 2 inputs to R3 and R4 
	JSR POP
	ADD R5, R5, x00
	BRn INVALID
	ADD R4, R0, x00
	JSR POP
	ADD R5, R5, x00
	BRp INVALID	; Broke
	ADD R3, R0, x00
	
; If statements to find the correct operaction to use
OPERADD			; Adds the numbers if it needs to
	LD R2, ASPL
	ADD R2, R2, R1
	BRnp OPERSUB	; Not add
	JSR PLUS
	JSR PUSH
	ADD R5, R5, x00
	BRp INVALID	; Broke
	BRnzp START

OPERSUB			; Subtracts the numbers if it needs to
	LD R2, ASMIN
	ADD R2, R2, R1
	BRnp OPERMUL	; Not subtract
	JSR MIN
	JSR PUSH
	ADD R5, R5, x00
	BRp INVALID	; Broke
	BRnzp START
	
OPERMUL			; Multiplies the numbers if it needs to
	LD R2, ASMUL
	ADD R2, R2, R1
	BRnp OPERDIV	; Not multiply
	JSR MUL
	JSR PUSH
	ADD R5, R5, x00
	BRp INVALID	; Broke
	BRnzp START

OPERDIV			; Divides the numbers if it needs to
	LD R2, ASDIV
	ADD R2, R2, R1
	BRnp OPERPOW	; Not divide
	JSR DIV
	JSR PUSH
	ADD R5, R5, x00
	BRp INVALID	; Broke
	BRnzp START

OPERPOW			; Powers the numbers if it needs to
	LD R2, ASPOW
	ADD R2, R2, R1
	BRnp INVALID	; Not an operation, invalid expression
	JSR EXP
	JSR PUSH
	ADD R5, R5, x00
	BRp INVALID	; Broke
	BRnzp START

; Adds the digit to the stack
DIGIT
	ADD R0, R2, x00
	JSR PUSH
	ADD R5, R5, x00
	BRp INVALID
	BRnzp START

; Print out the string "Invalid Expression"
INVALID
	LEA R0, INV	; Load the address of the string
	PUTS		; Print the string to the console
	HALT		; Broke, quit

;Finish the program
FIN
	JSR POP
	ADD R5, R5, x00
	BRp INVALID
	ADD R1, R0, x00
	JSR POP
	ADD R5, R5, x00
	BRnz INVALID
	ADD R5, R1, x00
	JSR PRINTHEX
	HALT


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This part of the code prints a string representing the hex value in R3. It
; splits the number into 4 bit chunks, and prints each one out as a character.
; If the 4-bit value is over 9, it prints a number 'A'-'F', otherwise it prints
; the number '0'-'9'.
;
; Table of registers:
;	R0: What to print
;	R1: The character counter
;	R2: The bit counter
;	R5: The number to print
;	R6: Temp register
PRINTHEX
	ST R0, expStR0
	ST R1, expStR1
	ST R2, expStR2
	ST R6, expStR6
	
	AND R1, R1, x00
	ADD R1, R1, x04	; Set R1 to 4

DGTCOUNT
	AND R1, R1, R1
	BRnz CONT	; If no digits are left, continue

	AND R2, R2, x00
	ADD R2, R2, x04
	AND R0, R0, x00	; Set R2 to 4 and R0 to 0

BITCOUNT
	AND R2, R2, R2
	BRz PRINT	; If no bits are left print the character

	ADD R0, R0, R0
	AND R5, R5, R5
	BRzp ADDZERO

	ADD R0, R0, x01	; If R3 is negative, next bit is 1, otherwise 0

ADDZERO
	ADD R5, R5, R5
	ADD R2, R2, x1F
	BRnzp BITCOUNT	; Left shift R3 and go to the next bit


PRINT
	ADD R6, R0, x17
	BRnz LESS
	LD R6, A_MIN_TEN
	BRnzp FINCHAR

LESS
	LD R6, POS_ZERO	; If R0 is less than 9, load '0', otherwise 'A'-10

FINCHAR
	ADD R0, R0, R6
	ST R7, expStR7
	OUT		; Print the correct ASCII value
	LD R7, expStR7	; OUT changes R7

	ADD R1, R1, x1F
	BRnzp DGTCOUNT	; Start the next digit
	
	LD R0, expStR0
	LD R1, expStR1
	LD R2, expStR2
	LD R6, expStR6

CONT
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
PLUS
	ADD R0, R3, R4
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
;R3-R4
MIN
	NOT R4, R4
	ADD R4, R4, x01
	ADD R0, R4, R3
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
MUL
	AND R0,R0,x0      ;clear R0 for output
LPML
	ADD R0,R0,R3    ;R0 plus R2
	ADD R4,R4,#-1   ;decrease counter
	BRp LPML 
	RET

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
;R3/R4	
DIV
	AND R0,R0, x00	;clear R0 for result 
	NOT R4,R4	;not R4 then
	ADD R4,R4,#1	;add 1
LPDIV
	ADD R3,R3,R4	;subtract R4 from R3
	BRn DIVDONE	; If negative, done
	ADD R0,R0,#1	;incr. counter
	BRnzp LPDIV	;loop if pos
DIVDONE
	RET
	
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;input R3, R4
;out R0
;R3^R4
EXP
	ST R1, expStR1
	ADD R1, R4, x00
	ADD R4, R3, x00
	
EXP_OP
	ADD R1, R1, x1F
	BRnz EXPDONE
	
	ST R7, expStR7
	JSR MUL
	LD R7, expStR7	; MUL changes R7
	ADD R4, R0, x00
	BRnzp EXP_OP
	
EXPDONE
	ADD R0, R4, x00
	LD R1, expStR1
	RET
	
; Register storage
expStR0	.BLKW 1
expStR1	.BLKW 1
expStR2	.BLKW 1
expStR6	.BLKW 1
expStR7	.BLKW 1

; For PRINTHEX
POS_ZERO	.FILL x0030	; The ASCII value of '0'
A_MIN_TEN	.FILL x0037	; The ASCII value of 'A' - 10

; All are 2's compliment negative
ASSP		.FILL xFFE0
ASMUL		.FILL xFFD6
ASPL		.FILL xFFD5
ASMIN		.FILL xFFD3
ASDIV		.FILL xFFD1
ASPOW		.FILL xFFA2
ASEQ		.FILL xFFC3
ASZERO		.FILL xFFD0
ASCOL		.FILL xFFC6

; The string to let the user know they did a bad
INV		.STRINGZ "Invalid Expression"

;IN:R0, OUT:R5 (0-success, 1-fail/overflow)
;R3: STACK_END R4: STACK_TOP
;
PUSH	
	ST R3, PUSH_SaveR3	;save R3
	ST R4, PUSH_SaveR4	;save R4
	AND R5, R5, #0		;
	LD R3, STACK_END	;
	LD R4, STACk_TOP	;
	ADD R3, R3, #-1		;
	NOT R3, R3		;
	ADD R3, R3, #1		;
	ADD R3, R3, R4		;
	BRz OVERFLOW		;stack is full
	STR R0, R4, #0		;no overflow, store value in the stack
	ADD R4, R4, #-1		;move top of the stack
	ST R4, STACK_TOP	;store top of stack pointer
	BRnzp DONE_PUSH		;
OVERFLOW
	ADD R5, R5, #1		;
DONE_PUSH
	LD R3, PUSH_SaveR3	;
	LD R4, PUSH_SaveR4	;
	RET


PUSH_SaveR3	.BLKW #1	;
PUSH_SaveR4	.BLKW #1	;


;OUT: R0, OUT R5 (0-success, 1-fail/underflow)
;R3 STACK_START R4 STACK_TOP
;
POP	
	ST R3, POP_SaveR3	;save R3
	ST R4, POP_SaveR4	;save R3
	AND R5, R5, #0		;clear R5
	LD R3, STACK_START	;
	LD R4, STACK_TOP	;
	NOT R3, R3		;
	ADD R3, R3, #1		;
	ADD R3, R3, R4		;
	BRz UNDERFLOW		;
	ADD R4, R4, #1		;
	LDR R0, R4, #0		;
	ST R4, STACK_TOP	;
	BRnzp DONE_POP		;
UNDERFLOW
	ADD R5, R5, #1		;
DONE_POP
	LD R3, POP_SaveR3	;
	LD R4, POP_SaveR4	;
	RET


POP_SaveR3	.BLKW #1	;
POP_SaveR4	.BLKW #1	;
STACK_END	.FILL x3FF0	;
STACK_START	.FILL x4000	;
STACK_TOP	.FILL x4000	;


.END
